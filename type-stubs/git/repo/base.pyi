# Stubs for git.repo.base (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from collections import namedtuple
from typing import Any, Optional

BlameEntry = namedtuple('BlameEntry', ['commit', 'linenos', 'orig_path', 'orig_linenos'])

class Repo:
    DAEMON_EXPORT_FILE: str = ...
    git: Any = ...
    working_dir: Any = ...
    git_dir: Any = ...
    re_whitespace: Any = ...
    re_hexsha_only: Any = ...
    re_hexsha_shortened: Any = ...
    re_author_committer_start: Any = ...
    re_tab_full_line: Any = ...
    config_level: Any = ...
    GitCommandWrapperType: Any = ...
    odb: Any = ...
    def __init__(self, path: Optional[Any] = ..., odbt: Any = ..., search_parent_directories: bool = ..., expand_vars: bool = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...
    def __del__(self) -> None: ...
    def close(self) -> None: ...
    def __eq__(self, rhs): ...
    def __ne__(self, rhs): ...
    def __hash__(self): ...
    description: Any = ...
    @property
    def working_tree_dir(self): ...
    @property
    def common_dir(self): ...
    @property
    def bare(self): ...
    @property
    def heads(self): ...
    @property
    def references(self): ...
    refs: Any = ...
    branches: Any = ...
    @property
    def index(self): ...
    @property
    def head(self): ...
    @property
    def remotes(self): ...
    def remote(self, name: str = ...): ...
    @property
    def submodules(self): ...
    def submodule(self, name): ...
    def create_submodule(self, *args, **kwargs): ...
    def iter_submodules(self, *args, **kwargs): ...
    def submodule_update(self, *args, **kwargs): ...
    @property
    def tags(self): ...
    def tag(self, path): ...
    def create_head(self, path, commit: str = ..., force: bool = ..., logmsg: Optional[Any] = ...): ...
    def delete_head(self, *heads, **kwargs): ...
    def create_tag(self, path, ref: str = ..., message: Optional[Any] = ..., force: bool = ..., **kwargs): ...
    def delete_tag(self, *tags): ...
    def create_remote(self, name, url, **kwargs): ...
    def delete_remote(self, remote): ...
    def config_reader(self, config_level: Optional[Any] = ...): ...
    def config_writer(self, config_level: str = ...): ...
    def commit(self, rev: Optional[Any] = ...): ...
    def iter_trees(self, *args, **kwargs): ...
    def tree(self, rev: Optional[Any] = ...): ...
    def iter_commits(self, rev: Optional[Any] = ..., paths: str = ..., **kwargs): ...
    def merge_base(self, *rev, **kwargs): ...
    def is_ancestor(self, ancestor_rev, rev): ...
    daemon_export: Any = ...
    alternates: Any = ...
    def is_dirty(self, index: bool = ..., working_tree: bool = ..., untracked_files: bool = ..., submodules: bool = ..., path: Optional[Any] = ...): ...
    @property
    def untracked_files(self): ...
    @property
    def active_branch(self): ...
    def blame_incremental(self, rev, file, **kwargs) -> None: ...
    def blame(self, rev, file, incremental: bool = ..., **kwargs): ...
    @classmethod
    def init(cls, path: Optional[Any] = ..., mkdir: bool = ..., odbt: Any = ..., expand_vars: bool = ..., **kwargs): ...
    def clone(self, path, progress: Optional[Any] = ..., **kwargs): ...
    @classmethod
    def clone_from(cls, url, to_path, progress: Optional[Any] = ..., env: Optional[Any] = ..., **kwargs): ...
    def archive(self, ostream, treeish: Optional[Any] = ..., prefix: Optional[Any] = ..., **kwargs): ...
    def has_separate_working_tree(self): ...
    rev_parse: Any = ...
